#include <stdint.h>
#include <stdarg.h>
#include <Arduino.h>
#include <SPI.h>
#include "EPD.h"

#define BITS_PER_PIXEL (2)
#define PIXELS_PER_BYTE (8 / BITS_PER_PIXEL)

static const uint8_t lut_4Gray_GC[] = {
	0x2A, 0x06, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x28, 0x06, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x20, 0x06, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x14, 0x06, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x02, 0x02, 0x0A, 0x00, 0x00, 0x00, 0x08, 0x08, 0x02,
	0x00, 0x02, 0x02, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x22, 0x22, 0x22, 0x22, 0x22};

static const uint8_t lut_1Gray_DU[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x01, 0x2A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0A, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x05, 0x05, 0x00, 0x05, 0x03, 0x05, 0x05, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x22, 0x22, 0x22, 0x22, 0x22};

static const uint8_t lut_1Gray_A2[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x03, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x22, 0x22, 0x22, 0x22, 0x22

};

// PIN 10 - CS
// PIN 11 - MOSI

SPISettings spiSettings(4000000, MSBFIRST, SPI_MODE0);

EPD::EPD(int pinRST, int pinDC, int pinCS, int pinBUSY)
{
	RST = pinRST;
	DC = pinDC;
	CS = pinCS;
	BUSY = pinBUSY;

	// Configure GP Pins
	pinMode(RST, OUTPUT);
	pinMode(DC, OUTPUT);
	pinMode(CS, OUTPUT);
	pinMode(BUSY, INPUT);

	// Disable CS
	digitalWrite(CS, HIGH);

	// Configure SPI
	SPI.begin();
}

void EPD::sendCommand(uint8_t command)
{
	// Let the device know this is a command
	digitalWrite(DC, LOW);

	// SPI CS enable
	digitalWrite(CS, LOW);

	// Send command
	SPI.beginTransaction(spiSettings);

	SPI.transfer(command);

	SPI.endTransaction();

	// SPI CS disable
	digitalWrite(CS, HIGH);
}

void EPD::sendData(size_t nbytes, ...)
{
	size_t i;
	va_list ap;

	// Let the device know this is data
	digitalWrite(DC, HIGH);

	// SPI CS enable
	digitalWrite(CS, LOW);

	// Parse arguments
	va_start(ap, nbytes);

	SPI.beginTransaction(spiSettings);

	for (i = 0; i < nbytes; ++i)
	{
		SPI.transfer(va_arg(ap, int));
	}

	SPI.endTransaction();

	// Finish argparse
	va_end(ap);

	// SPI CS disable
	digitalWrite(CS, HIGH);
}

void EPD::readBusy()
{
	while (digitalRead(BUSY))
	{
		Serial.println("Device busy...");
		delay(10);
	}
}

void EPD::reset(enum ColorMode mode)
{
	// Do the rain dance to reset the device
	digitalWrite(RST, HIGH);
	delay(200);
	digitalWrite(RST, LOW);
	delay(5);
	digitalWrite(RST, HIGH);
	delay(200);

	// Run some undocumented voodoo commands and delays
	sendCommand(0x12);
	delay(300);

	sendCommand(0x46);
	sendData(DATA(0xf7));
	readBusy();

	sendCommand(0x47);
	sendData(DATA(0xf7));
	readBusy();

	// Setting gaet number
	sendCommand(0x01);
	sendData(DATA(0xdf, 0x01, 0x00));

	// Set gate voltage
	sendCommand(0x03);
	sendData(DATA(0x00));

	// Set source voltage
	sendCommand(0x04);

	sendData(DATA(0x41, 0xa8, 0x32));

	// Set data entry sequence
	sendCommand(0x11);
	sendData(DATA(0x03));

	// Set border
	sendCommand(0x3c);
	sendData(DATA(0x03));

	// Set booster strength
	sendCommand(0x0c);
	sendData(DATA(0xae, 0xc7, 0xc3, 0xc0, 0xc0));

	// Set internal sensor on
	sendCommand(0x18);
	sendData(DATA(0x80));

	// Set vcom value
	sendCommand(0x2c);
	sendData(DATA(0x44));

	if (mode == MODE_MONOCHROME)
	{
		// Set display option, these setting turn on previous function
		sendCommand(0x37);
		sendData(DATA(0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00));
	}
	else
	{
		// Set display option, these setting turn on previous function
		sendCommand(0x37);

		// Can switch 1 gray or 4 gray
		sendData(DATA(0x00, 0xff, 0xff, 0xff, 0xff, 0x4f, 0xff, 0xff, 0xff, 0xff));
	}

	// Set X direction start/end position of RAM
	sendCommand(0x44);
	sendData(DATA(0x00, 0x00, 0x17, 0x01));
	// Set Y direction start/end position of RAM
	sendCommand(0x45);
	sendData(DATA(0x00, 0x00, 0xdf, 0x01));
	// Display update control 2
	sendCommand(0x22);
	sendData(DATA(0xcf));

	// Remember color mode for future functionality
	colorMode = mode;
}

void EPD::loadLUT(const uint8_t *lut, size_t size)
{
	unsigned int i;

	sendCommand(0x32);

	for (i = 0; i < 105; ++i)
	{
		sendData(DATA(lut[i]));
	}
}

void EPD::clear()
{
	unsigned int i;
	unsigned int j;

	sendCommand(0x4e);
	sendData(DATA(0x00, 0x00));
	sendCommand(0x4f);
	sendData(DATA(0x00, 0x00));

	sendCommand(0x24);

	for (i = 0; i < height; ++i)
	{
		for (j = 0; j < width / 8; ++j)
		{
			sendData(DATA(0xff));
		}
	}

	if (colorMode == MODE_MONOCHROME)
	{
		sendCommand(0x26);

		for (i = 0; i < height; ++i)
		{
			for (j = 0; j < width / 8; ++j)
			{
				sendData(DATA(0xff));
			}
		}

		loadLUT(lut_4Gray_GC, sizeof(lut_4Gray_GC));

		sendCommand(0x22);
		sendData(DATA(0xc7));
	}
	else if (colorMode == MODE_BLACKWHITE)
	{
		loadLUT(lut_4Gray_GC, sizeof(lut_1Gray_DU));
	}

	sendCommand(0x20);
	readBusy();
}

void EPD::displayStartChannel(enum MonochromeChannel channel)
{
	// Prepare for drawing
	sendCommand(0x4e);
	sendData(DATA(0x00, 0x00));

	sendCommand(0x4f);
	sendData(DATA(0x00, 0x00));

	sendCommand((uint8_t)channel);
}

void EPD::displayPixels(enum MonochromePixelColor image[4])
{
	size_t pixelIdx;
	uint8_t data = image[0];

	for (pixelIdx = 1; pixelIdx < PIXELS_PER_BYTE; ++pixelIdx)
	{
		data <<= BITS_PER_PIXEL;
		data |= (uint8_t)image[pixelIdx];
	}

	sendData(DATA(data));
}

void EPD::displayFinalize()
{
	// Finalize
	if (colorMode == MODE_MONOCHROME)
	{
		loadLUT(lut_4Gray_GC, sizeof(lut_4Gray_GC));

		sendCommand(0x22);
		sendData(DATA(0xc7));
	}
	else
	{
		loadLUT(lut_1Gray_A2, sizeof(lut_1Gray_A2));
	}

	sendCommand(0x20);
	readBusy();
}

void EPD::display(enum MonochromePixelColor *image)
{
	size_t grayIdx;
	size_t i;
	size_t channels;
	enum MonochromeChannel gray_channels[] = {MONOCHROME_CHANNEL_LIGHT_GRAY, MONOCHROME_CHANNEL_DARK_GRAY};

	if (colorMode == MODE_MONOCHROME)
	{
		channels = 2;
	}
	else
	{
		channels = 1;
	}

	for (grayIdx = 0; grayIdx < channels; ++grayIdx)
	{
		displayStartChannel(gray_channels[grayIdx]);

		// Convert image to 4 grayscale
		for (i = 0; i < height * width; i += PIXELS_PER_BYTE)
		{
			displayPixels(image + i);
		}
	}

	displayFinalize();
}

EPD::~EPD()
{
	digitalWrite(RST, LOW);
	digitalWrite(DC, LOW);
}